/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Author: 991519166 (https://sketchfab.com/991519166)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/galaxy-dbb2f075329747a09cc8add2ad05acad
Title: Sun
*/

import { useRef, useEffect, useState } from 'react';
import { useAnimations, useGLTF } from '@react-three/drei';
import { useFrame, useThree } from '@react-three/fiber';
import { useDrag } from 'react-use-gesture';
import sunScene from '../assets/3d/sun.glb';


const Sun = ({ setCurrentStage, setSunDragging, sunDragging, ...props }) => {
  const sunRef = useRef();
  const { scene, animations } = useGLTF(sunScene);
  const { actions } = useAnimations(animations, sunRef);
  const [velocity, setVelocity] = useState({ x: 0, y: 0 });
  const [hasBeenDragged, setHasBeenDragged] = useState(false);
  const { size } = useThree();
  const [bounds, setBounds] = useState({ x: 5, y: 5, z: 5 });
  const [stablePosition, setStablePosition] = useState({ x: 0, y: -5, z: 0 });
  
  const isMobile = window.innerWidth <= 768 && window.innerWidth <= window.innerHeight;
  const isMobileLandscape = window.innerWidth <= 768 && window.innerWidth >= window.innerHeight;
  const isPortrait = window.innerWidth > 768 && window.innerWidth <= window.innerHeight;
  const isVeryLowRes = window.innerWidth > 768 && window.innerWidth < 1200 && window.innerWidth >= window.innerHeight;
  const isLowRes = window.innerWidth >= 1200 && window.innerWidth < 1600 && window.innerWidth >= window.innerHeight;
  const isMidRes = window.innerWidth >= 1600 && window.innerWidth < 2100 && window.innerWidth >= window.innerHeight;
  const isHighRes = window.innerWidth >= 2100 && window.innerWidth < 2800 && window.innerWidth >= window.innerHeight;
  const isVeryHighRes = window.innerWidth >= 2800 && window.innerWidth >= window.innerHeight;
  
  
  useEffect(() => {
    actions['Take 001'].play();
  }, [])


  useEffect(() => {
    let newBounds;
    if (isMobile) {
      newBounds = {
        x: size.width / 120,
        y: size.height / 120,
      };
    } else if (isMobileLandscape) {
      newBounds = {
        x: size.width / 60,
        y: size.height / 60,
      };
    } else if (isVeryLowRes) {
      newBounds = {
        x: size.width / 90,
        y: size.height / 90,
      };
    } else if (isPortrait) {
      newBounds = {
        x: size.width / 140,
        y: size.height / 140,
      };
    } else if (isLowRes) {
      newBounds = {
        x: size.width / 110,
        y: size.height / 110,
      };
    } else if (isMidRes) {
      newBounds = {
        x: size.width / 140,
        y: size.height / 140,
      };
    } else if (isHighRes) {
      newBounds = {
        x: size.width / 190,
        y: size.height / 190,
      };
    } else if (isVeryHighRes) {
      newBounds = {
        x: size.width / 250,
        y: size.height / 250,
      };
    } else {
      newBounds = {
        x: size.width / 140,
        y: size.height / 140,
      };
    }
    setBounds(newBounds);
  }, [window]);


  const bind = useDrag(({ xy: [x, y], down, movement: [mx, my], event }) => {
    const isTouch = event.touches && event.touches.length > 0;
    const scaleFactor = isTouch ? 400 : 800;
    const xPosition = (x - size.width / 2) / 60;
    const yPosition = (size.height / 2 - y) / 60;
    
  
    if (down) {
      sunRef.current.position.x = xPosition;
      sunRef.current.position.y = yPosition;
      setCurrentStage(null);

      if (!sunDragging) {
        setSunDragging(true);
      }
      if (!hasBeenDragged) {
        setStablePosition({
          x: sunRef.current.position.x,
          y: sunRef.current.position.y,
          z: sunRef.current.position.z
        });
        setHasBeenDragged(true);
      }
    } else {
      setVelocity({
        x: mx / scaleFactor,
        y: -my / scaleFactor,
      });
      setSunDragging(false);
    }
  }, { pointerEvents: true });


  useFrame(({ clock }) => {
    if (!hasBeenDragged) {
      const a = 11;
      const b = -2;
      const c = 10;
      const speed = 0.5;

      sunRef.current.position.x = a * Math.cos(speed * clock.elapsedTime);
      sunRef.current.position.y = b * Math.sin(speed * clock.elapsedTime) - 1;
      sunRef.current.position.z = c * Math.sin(speed * clock.elapsedTime) - 18;
    } else if (sunRef.current.position.z < -6 && isMobile) {
      sunRef.current.position.z = -6;
    } else if (sunRef.current.position.z < -6 && !isMobile) {
      sunRef.current.position.z = -6;
    }

    sunRef.current.position.x += velocity.x;
    sunRef.current.position.y += velocity.y;

    const dampingFactor = 0.98;
    
    setVelocity(v => ({
      x: v.x * dampingFactor,
      y: v.y * dampingFactor
    }));

    if (hasBeenDragged) {
      if (sunRef.current.position.x > bounds.x) {
        sunRef.current.position.x = bounds.x;
        setVelocity(v => ({ ...v, x: -Math.abs(v.x) }));
      } else if (sunRef.current.position.x < -bounds.x) {
        sunRef.current.position.x = -bounds.x;
        setVelocity(v => ({ ...v, x: Math.abs(v.x) }));
      }
  
      if (sunRef.current.position.y > bounds.y) {
        sunRef.current.position.y = bounds.y;
        setVelocity(v => ({ ...v, y: -Math.abs(v.y) }));
      } else if (sunRef.current.position.y < -bounds.y) {
        sunRef.current.position.y = -bounds.y;
        setVelocity(v => ({ ...v, y: Math.abs(v.y) }));
      }
    }
  });


  return (
    <mesh
      position={[2, -1.4, 0]}
      scale={[0.09, 0.09, 0.09]}
      ref={sunRef}
      {...bind()}
    >
      <primitive object={scene} />
    </mesh>
  );
}

export default Sun;